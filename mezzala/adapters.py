# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/adapters.ipynb (unless otherwise specified).

__all__ = ['KeyAdapter', 'AttributeAdapter', 'LumpedAdapter']

# Cell
import collections
import functools

import mezzala.parameters

# Cell


class KeyAdapter:
    """
    Get data from subscriptable objects.
    """

    def __init__(self, home_goals, away_goals, **kwargs):
        self._lookup = {
            'home_goals': home_goals,
            'away_goals': away_goals,
            **kwargs
        }

    def _get_in(self, row, item):
        if isinstance(item, list):
            return functools.reduce(lambda d, i: d[i], item, row)
        return row[item]

    def __getattr__(self, key):
        def getter(row):
            return self._get_in(row, self._lookup[key])
        return getter

# Cell


class AttributeAdapter:
    """
    Get data from object attributes.
    """
    def __init__(self, home_goals, away_goals, **kwargs):
        self._lookup = {
            'home_goals': home_goals,
            'away_goals': away_goals,
            **kwargs
        }

    def _get_in(self, row, item):
        if isinstance(item, list):
            return functools.reduce(getattr, item, row)
        return getattr(row, item)

    def __getattr__(self, key):
        def getter(row):
            return self._get_in(row, self._lookup[key])
        return getter

# Cell


class LumpedAdapter:
    """ Lump term values who appear below `min_observations` times (defaults to 10) into one term (`placeholder`)"""

    def __init__(self, base_adapter, data, placeholder, min_observations=10):
        self.base_adapter = base_adapter
        self.min_matches = min_matches
        self.placeholder = placeholder

        self.match_count = None
        self.train(data)

    def home_team(self, row):
        home_team = self.base_adapter.home_team(row)
        if self.match_count[home_team] <= self.min_matches:
            return self.placeholder
        return home_team

    def away_team(self, row):
        away_team = self.base_adapter.away_team(row)
        if self.match_count[away_team] <= self.min_matches:
            return self.placeholder
        return away_team

    def home_goals(self, row):
        return self.base_adapter.home_goals(row)

    def away_goals(self, row):
        return self.base_adapter.away_goals(row)

    def fit(self, data):
        home_match_count = collections.Counter(self.base_adapter.home_team(row) for row in data)
        away_match_count = collections.Counter(self.base_adapter.away_team(row) for row in data)
        self.match_count = home_match_count + away_match_count